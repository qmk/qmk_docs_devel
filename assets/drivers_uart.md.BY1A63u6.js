import { _ as _export_sfc, c as createElementBlock, o as openBlock, a8 as createStaticVNode } from "./chunks/framework.Cauyuiy8.js";
const __pageData = JSON.parse('{"title":"UART Driver","description":"","frontmatter":{},"headers":[],"relativePath":"drivers/uart.md","filePath":"drivers/uart.md","lastUpdated":1751656200000}');
const _sfc_main = { name: "drivers/uart.md" };
const _hoisted_1 = /* @__PURE__ */ createStaticVNode('<h1 id="uart-driver" tabindex="-1">UART Driver <a class="header-anchor" href="#uart-driver" aria-label="Permalink to &quot;UART Driver {#uart-driver}&quot;">​</a></h1><p>The UART drivers used in QMK have a set of common functions to allow portability between MCUs.</p><p>Currently, this driver does not support enabling hardware flow control (the <code>RTS</code> and <code>CTS</code> pins) if available, but may do so in future.</p><h2 id="usage" tabindex="-1">Usage <a class="header-anchor" href="#usage" aria-label="Permalink to &quot;Usage {#usage}&quot;">​</a></h2><p>In most cases, the UART driver code is automatically included if you are using a feature or driver which requires it.</p><p>However, if you need to use the driver standalone, add the following to your <code>rules.mk</code>:</p><div class="language-make vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">make</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">UART_DRIVER_REQUIRED = yes</span></span></code></pre></div><p>You can then call the UART API by including <code>uart.h</code> in your code.</p><h2 id="avr-configuration" tabindex="-1">AVR Configuration <a class="header-anchor" href="#avr-configuration" aria-label="Permalink to &quot;AVR Configuration {#avr-configuration}&quot;">​</a></h2><p>No special setup is required - just connect the <code>RX</code> and <code>TX</code> pins of your UART device to the opposite pins on the MCU:</p><table><thead><tr><th>MCU</th><th><code>TX</code></th><th><code>RX</code></th><th><code>CTS</code></th><th><code>RTS</code></th></tr></thead><tbody><tr><td>ATmega16/32U2</td><td><code>D3</code></td><td><code>D2</code></td><td><code>D7</code></td><td><code>D6</code></td></tr><tr><td>ATmega16/32U4</td><td><code>D3</code></td><td><code>D2</code></td><td><code>D5</code></td><td><code>B7</code></td></tr><tr><td>AT90USB64/128</td><td><code>D3</code></td><td><code>D2</code></td><td><em>n/a</em></td><td><em>n/a</em></td></tr><tr><td>ATmega32A</td><td><code>D1</code></td><td><code>D0</code></td><td><em>n/a</em></td><td><em>n/a</em></td></tr><tr><td>ATmega328/P</td><td><code>D1</code></td><td><code>D0</code></td><td><em>n/a</em></td><td><em>n/a</em></td></tr></tbody></table><h2 id="arm-configuration" tabindex="-1">ChibiOS/ARM Configuration <a class="header-anchor" href="#arm-configuration" aria-label="Permalink to &quot;ChibiOS/ARM Configuration {#arm-configuration}&quot;">​</a></h2><p>You&#39;ll need to determine which pins can be used for UART -- as an example, STM32 parts generally have multiple UART peripherals, labeled USART1, USART2, USART3 etc.</p><p>To enable UART, modify your board&#39;s <code>mcuconf.h</code> to enable the peripheral you&#39;ve chosen, for example:</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark has-focused-lines vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#pragma</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> once</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include_next</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;mcuconf.h&gt;</span></span>\n<span class="line"></span>\n<span class="line has-focus"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#undef</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> STM32_SERIAL_USE_USART2</span></span>\n<span class="line has-focus"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> STM32_SERIAL_USE_USART2</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> TRUE</span></span></code></pre></div><p>Configuration-wise, you&#39;ll need to set up the peripheral as per your MCU&#39;s datasheet -- the defaults match the pins for a Proton-C, i.e. STM32F303.</p><table><thead><tr><th><code>config.h</code> Override</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code>UART_DRIVER</code></td><td>USART peripheral to use - USART1 -&gt; <code>SD1</code>, USART2 -&gt; <code>SD2</code> etc.</td><td><code>SD1</code></td></tr><tr><td><code>UART_TX_PIN</code></td><td>The pin to use for TX</td><td><code>A9</code></td></tr><tr><td><code>UART_TX_PAL_MODE</code></td><td>The alternate function mode for TX</td><td><code>7</code></td></tr><tr><td><code>UART_RX_PIN</code></td><td>The pin to use for RX</td><td><code>A10</code></td></tr><tr><td><code>UART_RX_PAL_MODE</code></td><td>The alternate function mode for RX</td><td><code>7</code></td></tr><tr><td><code>UART_CTS_PIN</code></td><td>The pin to use for CTS</td><td><code>A11</code></td></tr><tr><td><code>UART_CTS_PAL_MODE</code></td><td>The alternate function mode for CTS</td><td><code>7</code></td></tr><tr><td><code>UART_RTS_PIN</code></td><td>The pin to use for RTS</td><td><code>A12</code></td></tr><tr><td><code>UART_RTS_PAL_MODE</code></td><td>The alternate function mode for RTS</td><td><code>7</code></td></tr></tbody></table><h2 id="api" tabindex="-1">API <a class="header-anchor" href="#api" aria-label="Permalink to &quot;API {#api}&quot;">​</a></h2><h3 id="api-uart-init" tabindex="-1"><code>void uart_init(uint32_t baud)</code> <a class="header-anchor" href="#api-uart-init" aria-label="Permalink to &quot;`void uart_init(uint32_t baud)` {#api-uart-init}&quot;">​</a></h3><p>Initialize the UART driver. This function must be called only once, before any of the below functions can be called.</p><h4 id="api-uart-init-arguments" tabindex="-1">Arguments <a class="header-anchor" href="#api-uart-init-arguments" aria-label="Permalink to &quot;Arguments {#api-uart-init-arguments}&quot;">​</a></h4><ul><li><code>uint32_t baud</code><br> The baud rate to transmit and receive at. This may depend on the device you are communicating with. Common values are 1200, 2400, 4800, 9600, 19200, 38400, 57600, and 115200.</li></ul><hr><h3 id="api-uart-write" tabindex="-1"><code>void uart_write(uint8_t data)</code> <a class="header-anchor" href="#api-uart-write" aria-label="Permalink to &quot;`void uart_write(uint8_t data)` {#api-uart-write}&quot;">​</a></h3><p>Transmit a single byte.</p><h4 id="api-uart-write-arguments" tabindex="-1">Arguments <a class="header-anchor" href="#api-uart-write-arguments" aria-label="Permalink to &quot;Arguments {#api-uart-write-arguments}&quot;">​</a></h4><ul><li><code>uint8_t data</code><br> The byte to write.</li></ul><hr><h3 id="api-uart-read" tabindex="-1"><code>uint8_t uart_read(void)</code> <a class="header-anchor" href="#api-uart-read" aria-label="Permalink to &quot;`uint8_t uart_read(void)` {#api-uart-read}&quot;">​</a></h3><p>Receive a single byte.</p><h4 id="api-uart-read-return" tabindex="-1">Return Value <a class="header-anchor" href="#api-uart-read-return" aria-label="Permalink to &quot;Return Value {#api-uart-read-return}&quot;">​</a></h4><p>The byte read from the receive buffer. This function will block if the buffer is empty (ie. no data to read).</p><hr><h3 id="api-uart-transmit" tabindex="-1"><code>void uart_transmit(const uint8_t *data, uint16_t length)</code> <a class="header-anchor" href="#api-uart-transmit" aria-label="Permalink to &quot;`void uart_transmit(const uint8_t *data, uint16_t length)` {#api-uart-transmit}&quot;">​</a></h3><p>Transmit multiple bytes.</p><h4 id="api-uart-transmit-arguments" tabindex="-1">Arguments <a class="header-anchor" href="#api-uart-transmit-arguments" aria-label="Permalink to &quot;Arguments {#api-uart-transmit-arguments}&quot;">​</a></h4><ul><li><code>const uint8_t *data</code><br> A pointer to the data to write from.</li><li><code>uint16_t length</code><br> The number of bytes to write. Take care not to overrun the length of <code>data</code>.</li></ul><hr><h3 id="api-uart-receive" tabindex="-1"><code>void uart_receive(char *data, uint16_t length)</code> <a class="header-anchor" href="#api-uart-receive" aria-label="Permalink to &quot;`void uart_receive(char *data, uint16_t length)` {#api-uart-receive}&quot;">​</a></h3><p>Receive multiple bytes.</p><h4 id="api-uart-receive-arguments" tabindex="-1">Arguments <a class="header-anchor" href="#api-uart-receive-arguments" aria-label="Permalink to &quot;Arguments {#api-uart-receive-arguments}&quot;">​</a></h4><ul><li><code>uint8_t *data</code><br> A pointer to a buffer to read into.</li><li><code>uint16_t length</code><br> The number of bytes to read. Take care not to overrun the length of <code>data</code>.</li></ul><hr><h3 id="api-uart-available" tabindex="-1"><code>bool uart_available(void)</code> <a class="header-anchor" href="#api-uart-available" aria-label="Permalink to &quot;`bool uart_available(void)` {#api-uart-available}&quot;">​</a></h3><p>Return whether the receive buffer contains data. Call this function to determine if <code>uart_read()</code> will return data immediately.</p><h4 id="api-uart-available-return" tabindex="-1">Return Value <a class="header-anchor" href="#api-uart-available-return" aria-label="Permalink to &quot;Return Value {#api-uart-available-return}&quot;">​</a></h4><p><code>true</code> if there is data available to read.</p>', 47);
const _hoisted_48 = [
  _hoisted_1
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, _hoisted_48);
}
const uart = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export {
  __pageData,
  uart as default
};

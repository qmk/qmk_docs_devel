import { _ as _export_sfc, c as createElementBlock, o as openBlock, a8 as createStaticVNode } from "./chunks/framework.Cauyuiy8.js";
const __pageData = JSON.parse('{"title":"ISP Flashing Guide","description":"","frontmatter":{},"headers":[],"relativePath":"isp_flashing_guide.md","filePath":"isp_flashing_guide.md","lastUpdated":1751656200000}');
const _sfc_main = { name: "isp_flashing_guide.md" };
const _hoisted_1 = /* @__PURE__ */ createStaticVNode('<h1 id="isp-flashing-guide" tabindex="-1">ISP Flashing Guide <a class="header-anchor" href="#isp-flashing-guide" aria-label="Permalink to &quot;ISP Flashing Guide&quot;">​</a></h1><p>In order to flash a microcontroller over USB, it needs something called a bootloader. This bootloader lives in a specific section of the flash memory, and allows you to load the actual application firmware (in this case, QMK) into the rest of the flash.</p><p>However, it can sometimes happen that the bootloader becomes corrupted and needs reflashing, or you may want to change the bootloader to another one. It&#39;s not possible to do this with the existing bootloader, because, of course, it is already running, and cannot overwrite itself. Instead, you will need to ISP flash the microcontroller.</p><p>There are several different kinds of bootloaders available for AVR microcontrollers. Most STM32 ARM-based microcontrollers already have a USB-capable bootloader in ROM, so generally do not need to be ISP flashed. The one current exception is the <a href="#flashing-stm32duino-bootloader">STM32F103</a>.</p><h2 id="hardware" tabindex="-1">Hardware <a class="header-anchor" href="#hardware" aria-label="Permalink to &quot;Hardware&quot;">​</a></h2><p>One of the following devices is required to perform the ISP flashing. The product links are to the official versions, however you can certainly source them elsewhere.</p><p>You&#39;ll also need some jumper wires to connect the ISP flasher and the target board. Some boards have an ISP header with the necessary pins broken out. If not, then you will need to temporarily solder the wires to the PCB -- usually to switch pins or directly to the MCU. The wiring is fairly straightforward; for the most part, you&#39;ll be connecting like to like. Refer to the target MCU&#39;s datasheet for the exact <code>RESET</code>, <code>SCLK</code>, <code>MOSI</code> and <code>MISO</code> pins.</p><h3 id="pro-micro-as-isp" tabindex="-1">Pro Micro as ISP <a class="header-anchor" href="#pro-micro-as-isp" aria-label="Permalink to &quot;Pro Micro as ISP&quot;">​</a></h3><p><a href="https://www.sparkfun.com/products/12640" target="_blank" rel="noreferrer">SparkFun Pro Micro</a></p><p>To use a 5V/16MHz Pro Micro as an ISP flashing tool, you will first need to load a <a href="https://github.com/qmk/qmk_firmware/blob/master/util/pro_micro_ISP_B6_10.hex" target="_blank" rel="noreferrer">special firmware</a> onto it that emulates a hardware ISP flasher.</p><p><strong>AVRDUDE Programmer</strong>: <code>avrisp</code><br><strong>AVRDUDE Port</strong>: Serial</p><h4 id="wiring" tabindex="-1">Wiring <a class="header-anchor" href="#wiring" aria-label="Permalink to &quot;Wiring&quot;">​</a></h4><table><thead><tr><th>Pro Micro</th><th>Keyboard</th></tr></thead><tbody><tr><td><code>VCC</code></td><td><code>VCC</code></td></tr><tr><td><code>GND</code></td><td><code>GND</code></td></tr><tr><td><code>10</code> (<code>B6</code>)</td><td><code>RESET</code></td></tr><tr><td><code>15</code> (<code>B1</code>)</td><td><code>SCLK</code></td></tr><tr><td><code>16</code> (<code>B2</code>)</td><td><code>MOSI</code></td></tr><tr><td><code>14</code> (<code>B3</code>)</td><td><code>MISO</code></td></tr></tbody></table><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>Note that the <code>10</code> pin on the Pro Micro should be wired to the <code>RESET</code> pin on the keyboard&#39;s controller. <em><strong>DO NOT</strong></em> connect the <code>RESET</code> pin on the Pro Micro to the <code>RESET</code> on the keyboard.</p></div><h3 id="arduino-uno-micro-as-isp" tabindex="-1">Arduino Uno / Micro as ISP <a class="header-anchor" href="#arduino-uno-micro-as-isp" aria-label="Permalink to &quot;Arduino Uno / Micro as ISP&quot;">​</a></h3><p><a href="https://store.arduino.cc/products/arduino-uno-rev3" target="_blank" rel="noreferrer">Arduino Uno</a><a href="https://store.arduino.cc/products/arduino-micro" target="_blank" rel="noreferrer">Arduino Micro</a></p><p>A standard Uno or Micro can be used as an ISP flashing tool using the <a href="https://docs.arduino.cc/built-in-examples/arduino-isp/ArduinoISP#load-the-sketch" target="_blank" rel="noreferrer">example &quot;ArduinoISP&quot; sketch</a> to emulate an STK500 ISP. Also works with Sparkfun Pro Micros and clones.</p><p><strong>AVRDUDE Programmer</strong>: <code>stk500v1</code><br><strong>AVRDUDE Port</strong>: Serial</p><h4 id="wiring-1" tabindex="-1">Wiring <a class="header-anchor" href="#wiring-1" aria-label="Permalink to &quot;Wiring&quot;">​</a></h4><table><thead><tr><th>Uno</th><th>Keyboard</th></tr></thead><tbody><tr><td><code>5V</code></td><td><code>VCC</code></td></tr><tr><td><code>GND</code></td><td><code>GND</code></td></tr><tr><td><code>10</code> (<code>B2</code>)</td><td><code>RESET</code></td></tr><tr><td><code>13</code> (<code>B5</code>)</td><td><code>SCLK</code></td></tr><tr><td><code>11</code> (<code>B3</code>)</td><td><code>MOSI</code></td></tr><tr><td><code>12</code> (<code>B4</code>)</td><td><code>MISO</code></td></tr></tbody></table><table><thead><tr><th>Micro</th><th>Keyboard</th></tr></thead><tbody><tr><td><code>5V</code></td><td><code>VCC</code></td></tr><tr><td><code>GND</code></td><td><code>GND</code></td></tr><tr><td><code>10</code> (<code>B6</code>)</td><td><code>RESET</code></td></tr><tr><td><code>15</code> (<code>B1</code>)</td><td><code>SCLK</code></td></tr><tr><td><code>16</code> (<code>B2</code>)</td><td><code>MOSI</code></td></tr><tr><td><code>14</code> (<code>B3</code>)</td><td><code>MISO</code></td></tr></tbody></table><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>Note that the <code>10</code> pin on the Uno/Micro should be wired to the <code>RESET</code> pin on the keyboard&#39;s controller. <em><strong>DO NOT</strong></em> connect the <code>RESET</code> pin on the Uno/Micro to the <code>RESET</code> on the keyboard.</p></div><h3 id="teensy-2-0-as-isp" tabindex="-1">Teensy 2.0 as ISP <a class="header-anchor" href="#teensy-2-0-as-isp" aria-label="Permalink to &quot;Teensy 2.0 as ISP&quot;">​</a></h3><p><a href="https://www.pjrc.com/store/teensy.html" target="_blank" rel="noreferrer">PJRC Teensy 2.0</a></p><p>To use a Teensy 2.0 as an ISP flashing tool, you will first need to load a <a href="https://github.com/qmk/qmk_firmware/blob/master/util/teensy_2.0_ISP_B0.hex" target="_blank" rel="noreferrer">special firmware</a> onto it that emulates a hardware ISP flasher.</p><p><strong>AVRDUDE Programmer</strong>: <code>avrisp</code><br><strong>AVRDUDE Port</strong>: Serial</p><h4 id="wiring-2" tabindex="-1">Wiring <a class="header-anchor" href="#wiring-2" aria-label="Permalink to &quot;Wiring&quot;">​</a></h4><table><thead><tr><th>Teensy</th><th>Keyboard</th></tr></thead><tbody><tr><td><code>VCC</code></td><td><code>VCC</code></td></tr><tr><td><code>GND</code></td><td><code>GND</code></td></tr><tr><td><code>B0</code></td><td><code>RESET</code></td></tr><tr><td><code>B1</code></td><td><code>SCLK</code></td></tr><tr><td><code>B2</code></td><td><code>MOSI</code></td></tr><tr><td><code>B3</code></td><td><code>MISO</code></td></tr></tbody></table><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>Note that the <code>B0</code> pin on the Teensy should be wired to the <code>RESET</code> pin on the keyboard&#39;s controller. <em><strong>DO NOT</strong></em> connect the <code>RESET</code> pin on the Teensy to the <code>RESET</code> on the keyboard.</p></div><h3 id="sparkfun-pocketavr-usbtinyisp" tabindex="-1">SparkFun PocketAVR / USBtinyISP <a class="header-anchor" href="#sparkfun-pocketavr-usbtinyisp" aria-label="Permalink to &quot;SparkFun PocketAVR / USBtinyISP&quot;">​</a></h3><p><a href="https://www.sparkfun.com/products/9825" target="_blank" rel="noreferrer">SparkFun PocketAVR</a><br><a href="https://www.adafruit.com/product/46" target="_blank" rel="noreferrer">Adafruit USBtinyISP</a></p><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>SparkFun PocketAVR and USBtinyISP <strong>DO NOT support</strong> AVR chips with more than 64 KiB of flash (e.g., the AT90USB128 series). This limitation is mentioned on the <a href="https://www.sparkfun.com/products/9825" target="_blank" rel="noreferrer">shop page for SparkFun PocketAVR</a> and in the <a href="https://learn.adafruit.com/usbtinyisp/f-a-q#faq-2270879" target="_blank" rel="noreferrer">FAQ for USBtinyISP</a>. If you try to use one of these programmers with AT90USB128 chips, you will get verification errors from <code>avrdude</code>, and the bootloader won&#39;t be flashed properly (e.g., see the <a href="https://github.com/qmk/qmk_firmware/issues/3286" target="_blank" rel="noreferrer">issue #3286</a>).</p></div><p><strong>AVRDUDE Programmer</strong>: <code>usbtiny</code><br><strong>AVRDUDE Port</strong>: <code>usb</code></p><h4 id="wiring-3" tabindex="-1">Wiring <a class="header-anchor" href="#wiring-3" aria-label="Permalink to &quot;Wiring&quot;">​</a></h4><table><thead><tr><th>ISP</th><th>Keyboard</th></tr></thead><tbody><tr><td><code>VCC</code></td><td><code>VCC</code></td></tr><tr><td><code>GND</code></td><td><code>GND</code></td></tr><tr><td><code>RST</code></td><td><code>RESET</code></td></tr><tr><td><code>SCLK</code></td><td><code>SCLK</code></td></tr><tr><td><code>MOSI</code></td><td><code>MOSI</code></td></tr><tr><td><code>MISO</code></td><td><code>MISO</code></td></tr></tbody></table><h3 id="usbasp" tabindex="-1">USBasp <a class="header-anchor" href="#usbasp" aria-label="Permalink to &quot;USBasp&quot;">​</a></h3><p><a href="https://www.fischl.de/usbasp/" target="_blank" rel="noreferrer">Thomas Fischl&#39;s USBasp</a></p><p><strong>AVRDUDE Programmer</strong>: <code>usbasp</code><br><strong>AVRDUDE Port</strong>: <code>usb</code></p><h4 id="wiring-4" tabindex="-1">Wiring <a class="header-anchor" href="#wiring-4" aria-label="Permalink to &quot;Wiring&quot;">​</a></h4><table><thead><tr><th>ISP</th><th>Keyboard</th></tr></thead><tbody><tr><td><code>VCC</code></td><td><code>VCC</code></td></tr><tr><td><code>GND</code></td><td><code>GND</code></td></tr><tr><td><code>RST</code></td><td><code>RESET</code></td></tr><tr><td><code>SCLK</code></td><td><code>SCLK</code></td></tr><tr><td><code>MOSI</code></td><td><code>MOSI</code></td></tr><tr><td><code>MISO</code></td><td><code>MISO</code></td></tr></tbody></table><h3 id="bus-pirate" tabindex="-1">Bus Pirate <a class="header-anchor" href="#bus-pirate" aria-label="Permalink to &quot;Bus Pirate&quot;">​</a></h3><p><a href="https://www.adafruit.com/product/237" target="_blank" rel="noreferrer">Adafruit Bus Pirate</a></p><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>The 5-pin &quot;ICSP&quot; header is for ISP flashing the PIC microcontroller of the Bus Pirate. Connect your target board to the 10-pin header opposite the USB connector instead.</p></div><p><strong>AVRDUDE Programmer</strong>: <code>buspirate</code><br><strong>AVRDUDE Port</strong>: Serial</p><h4 id="wiring-5" tabindex="-1">Wiring <a class="header-anchor" href="#wiring-5" aria-label="Permalink to &quot;Wiring&quot;">​</a></h4><table><thead><tr><th>Bus Pirate</th><th>Keyboard</th></tr></thead><tbody><tr><td><code>+5V</code></td><td><code>VCC</code></td></tr><tr><td><code>GND</code></td><td><code>GND</code></td></tr><tr><td><code>RST</code></td><td><code>RESET</code></td></tr><tr><td><code>CLK</code></td><td><code>SCLK</code></td></tr><tr><td><code>MOSI</code></td><td><code>MOSI</code></td></tr><tr><td><code>MISO</code></td><td><code>MISO</code></td></tr></tbody></table><h2 id="software" tabindex="-1">Software <a class="header-anchor" href="#software" aria-label="Permalink to &quot;Software&quot;">​</a></h2><p><a href="https://github.com/qmk/qmk_toolbox/releases" target="_blank" rel="noreferrer">QMK Toolbox</a> supports flashing both the ISP firmware and bootloader, but note that it cannot (currently) set the AVR fuse bytes for the actual ISP flashing step, so you may want to work with <code>avrdude</code> directly instead.</p><p>Setting up the <a href="./newbs">QMK environment</a> is highly recommended, as it automatically installs <code>avrdude</code> along with a host of other tools.</p><h2 id="bootloader-firmware" tabindex="-1">Bootloader Firmware <a class="header-anchor" href="#bootloader-firmware" aria-label="Permalink to &quot;Bootloader Firmware&quot;">​</a></h2><p>One of these files is what you will be ISP flashing onto the board. The default fuses are also listed.</p><p>If you&#39;re not sure what your board uses, look in the <code>rules.mk</code> file for the keyboard in QMK. The <code>MCU</code> and <code>BOOTLOADER</code> lines will have the values you need. It may differ between different versions of the board.</p><h3 id="atmel-dfu" tabindex="-1">Atmel DFU <a class="header-anchor" href="#atmel-dfu" aria-label="Permalink to &quot;Atmel DFU&quot;">​</a></h3><p>These are the <a href="https://www.microchip.com/content/dam/mchp/documents/OTH/ProductDocuments/SoftwareLibraries/Firmware/megaUSB_DFU_Bootloaders.zip" target="_blank" rel="noreferrer">factory default bootloaders</a> shipped by Atmel (now Microchip). Note that the AT90USB64 and AT90USB128 bootloaders are <a href="https://github.com/qmk/qmk_firmware/pull/14064" target="_blank" rel="noreferrer">slightly modified</a>, due to a bug causing them to not enumerate properly in Windows 8 and later.</p><table><thead><tr><th>MCU</th><th>Low</th><th>High</th><th>Extended</th><th>USB ID</th></tr></thead><tbody><tr><td><a href="https://github.com/qmk/qmk_firmware/blob/master/util/bootloader_atmega16u4_1.0.1.hex" target="_blank" rel="noreferrer">ATmega16U4</a></td><td><code>0x5E</code></td><td><code>0x99</code> / <code>0xD9</code> (JTAG disabled)</td><td><code>0xF3</code></td><td><code>03EB:2FF3</code></td></tr><tr><td><a href="https://github.com/qmk/qmk_firmware/blob/master/util/bootloader_atmega32u4_1.0.0.hex" target="_blank" rel="noreferrer">ATmega32U4</a></td><td><code>0x5E</code></td><td><code>0x99</code> / <code>0xD9</code> (JTAG disabled)</td><td><code>0xF3</code></td><td><code>03EB:2FF4</code></td></tr><tr><td><a href="https://github.com/qmk/qmk_firmware/blob/master/util/bootloader_at90usb64_1.0.0.hex" target="_blank" rel="noreferrer">AT90USB64</a></td><td><code>0x5E</code></td><td><code>0x9B</code> / <code>0xDB</code> (JTAG disabled)</td><td><code>0xF3</code></td><td><code>03EB:2FF9</code></td></tr><tr><td><a href="https://github.com/qmk/qmk_firmware/blob/master/util/bootloader_at90usb128_1.0.1.hex" target="_blank" rel="noreferrer">AT90USB128</a></td><td><code>0x5E</code></td><td><code>0x99</code> / <code>0xD9</code> (JTAG disabled)</td><td><code>0xF3</code></td><td><code>03EB:2FFB</code></td></tr></tbody></table><h3 id="caterina" tabindex="-1">Caterina <a class="header-anchor" href="#caterina" aria-label="Permalink to &quot;Caterina&quot;">​</a></h3><p>This is the default Arduino-style bootloader derived from the <a href="https://github.com/abcminiuser/lufa/tree/master/Bootloaders/CDC" target="_blank" rel="noreferrer">LUFA CDC bootloader</a>, and is only for the ATmega32U4.</p><p>There are several variants depending on the vendor, but they all mostly work the same way. The SparkFun variants, for example, require the <code>RESET</code> pin to be <a href="https://learn.sparkfun.com/tutorials/pro-micro--fio-v3-hookup-guide#ts-reset" target="_blank" rel="noreferrer">grounded twice quickly</a> in order to stay in bootloader mode for more than 750 ms.</p><table><thead><tr><th>MCU</th><th>Low</th><th>High</th><th>Extended</th><th>USB ID</th></tr></thead><tbody><tr><td><a href="https://github.com/sparkfun/Arduino_Boards/blob/master/sparkfun/avr/bootloaders/caterina/Caterina-promicro8.hex" target="_blank" rel="noreferrer">SparkFun Pro Micro (3V3/8MHz)</a></td><td><code>0xFF</code></td><td><code>0xD8</code></td><td><code>0xFE</code></td><td><code>1B4F:9203</code></td></tr><tr><td><a href="https://github.com/sparkfun/Arduino_Boards/blob/master/sparkfun/avr/bootloaders/caterina/Caterina-promicro16.hex" target="_blank" rel="noreferrer">SparkFun Pro Micro (5V/16MHz)</a></td><td><code>0xFF</code></td><td><code>0xD8</code></td><td><code>0xFB</code></td><td><code>1B4F:9205</code></td></tr><tr><td><a href="https://github.com/sparkfun/Arduino_Boards/blob/main/sparkfun/avr/bootloaders/caterina/Caterina-lilypadusb.hex" target="_blank" rel="noreferrer">SparkFun LilyPadUSB (and some Pro Micro clones)</a></td><td><code>0xFF</code></td><td><code>0xD8</code></td><td><code>0xFE</code></td><td><code>1B4F:9207</code></td></tr><tr><td><a href="https://github.com/pololu/a-star/blob/master/bootloaders/caterina/Caterina-A-Star.hex" target="_blank" rel="noreferrer">Pololu A-Star 32U4</a>*</td><td><code>0xFF</code></td><td><code>0xD0</code></td><td><code>0xF8</code></td><td><code>1FFB:0101</code></td></tr><tr><td><a href="https://github.com/adafruit/Caterina-Bootloader/blob/master/Built%20Firmwares/Caterina-Feather32u4.hex" target="_blank" rel="noreferrer">Adafruit Feather 32U4</a></td><td><code>0xFF</code></td><td><code>0xD8</code></td><td><code>0xFB</code></td><td><code>239A:000C</code></td></tr><tr><td><a href="https://github.com/adafruit/Caterina-Bootloader/blob/master/Caterina_itsybitsy3V.hex" target="_blank" rel="noreferrer">Adafruit ItsyBitsy 32U4 (3V3/8MHz)</a>*</td><td><code>0xFF</code></td><td><code>0xD8</code></td><td><code>0xFB</code></td><td><code>239A:000D</code></td></tr><tr><td><a href="https://github.com/adafruit/Caterina-Bootloader/blob/master/Caterina_itsybitsy5V.hex" target="_blank" rel="noreferrer">Adafruit ItsyBitsy 32U4 (5V/16MHz)</a></td><td><code>0xFF</code></td><td><code>0xD8</code></td><td><code>0xFB</code></td><td><code>239A:000E</code></td></tr><tr><td><a href="https://github.com/arduino/ArduinoCore-avr/blob/master/bootloaders/caterina/Caterina-Leonardo.hex" target="_blank" rel="noreferrer">Arduino Leonardo</a>*</td><td><code>0xFF</code></td><td><code>0xD8</code></td><td><code>0xFB</code></td><td><code>2341:0036</code></td></tr><tr><td><a href="https://github.com/arduino/ArduinoCore-avr/blob/master/bootloaders/caterina/Caterina-Micro.hex" target="_blank" rel="noreferrer">Arduino Micro</a>*</td><td><code>0xFF</code></td><td><code>0xD8</code></td><td><code>0xFB</code></td><td><code>2341:0037</code></td></tr></tbody></table><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>Files marked with a * have combined Arduino sketches, which runs by default and also appears as a serial port. However, this is <em>not</em> the bootloader device.</p></div><h3 id="bootloadhid-ps2avrgb" tabindex="-1">BootloadHID (PS2AVRGB) <a class="header-anchor" href="#bootloadhid-ps2avrgb" aria-label="Permalink to &quot;BootloadHID (PS2AVRGB)&quot;">​</a></h3><p>This bootloader is primarily for keyboards originally designed for the PS2AVRGB firmware and Bootmapper Client. It is not recommended for use in new designs.</p><table><thead><tr><th>MCU</th><th>Low</th><th>High</th><th>USB ID</th></tr></thead><tbody><tr><td><a href="https://github.com/qmk/qmk_firmware/blob/master/util/bootloader_ps2avrgb_bootloadhid_1.0.1.hex" target="_blank" rel="noreferrer">ATmega32A</a></td><td><code>0x0F</code></td><td><code>0xD0</code></td><td><code>16C0:05DF</code></td></tr></tbody></table><h3 id="usbasploader" tabindex="-1">USBaspLoader <a class="header-anchor" href="#usbasploader" aria-label="Permalink to &quot;USBaspLoader&quot;">​</a></h3><p>USBaspLoader is a bootloader based on V-USB that emulates a hardware USBasp device. It runs on ATmega32A and ATmega328P MCUs.</p><p>Precompiled <code>.hex</code> files are generally not available, but you can compile it yourself by setting up the QMK environment and following Coseyfannitutti&#39;s guide for the appropriate MCU:</p><table><thead><tr><th>MCU</th><th>Low</th><th>High</th><th>Extended</th><th>USB ID</th></tr></thead><tbody><tr><td><a href="https://github.com/coseyfannitutti/discipline/tree/master/doc/bootloader" target="_blank" rel="noreferrer">ATmega32A</a></td><td><code>0x1F</code></td><td><code>0xC0</code></td><td><em>n/a</em></td><td><code>16C0:05DC</code></td></tr><tr><td><a href="https://github.com/coseyfannitutti/discipad/tree/master/doc/bootloader" target="_blank" rel="noreferrer">ATmega328P</a></td><td><code>0xD7</code></td><td><code>0xD0</code></td><td><code>0x04</code></td><td><code>16C0:05DC</code></td></tr></tbody></table><p>Note that some boards may have their own specialized build of this bootloader in a separate repository. This will usually be linked to in the board&#39;s readme.</p><h2 id="flashing-the-bootloader" tabindex="-1">Flashing the Bootloader <a class="header-anchor" href="#flashing-the-bootloader" aria-label="Permalink to &quot;Flashing the Bootloader&quot;">​</a></h2><p>Open a new Terminal window - if you are on Windows, use MSYS2 or QMK MSYS, not the Command Prompt. Navigate to the directory your bootloader <code>.hex</code> is in. Now it&#39;s time to run the <code>avrdude</code> command.</p><p>The syntax of <code>avrdude</code> is:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>avrdude -c &lt;programmer&gt; -P &lt;port&gt; -p &lt;mcu&gt; -U flash:w:&lt;filename&gt;:i</span></span></code></pre></div><ul><li><code>&lt;programmer&gt;</code> corresponds to the programmer type listed for each ISP flasher in the <a href="#hardware">Hardware</a> section, for example <code>avrisp</code>.</li><li><code>&lt;port&gt;</code> is the serial port that appears when you plug the ISP flasher in, if any. For some programmers this is simply <code>usb</code> (or you can omit the <code>-P</code> argument completely) since they do not operate as a serial device. <ul><li>Windows: <code>COMx</code> - check Device Manager, under the &quot;Ports (COM &amp; LPT)&quot; section</li><li>Linux: <code>/dev/ttyACMx</code></li><li>macOS: <code>/dev/tty.usbmodemXXXXXX</code></li></ul></li><li><code>&lt;mcu&gt;</code> should be the lowercase name of the target AVR microcontroller, for example <code>atmega32u4</code>.</li><li><code>&lt;filename&gt;</code> is the absolute or relative path to the bootloader to be flashed, for example <code>Caterina-Micro.hex</code>.</li></ul><p>You can also run <code>man avrdude</code> for more information.</p><p>If all goes well, you should get output similar to the following:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>avrdude: AVR device initialized and ready to accept instructions</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>Reading | ################################################## | 100% 0.00s</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>avrdude: Device signature = 0x1e9587 (probably m32u4)</span></span>\n<span class="line"><span>avrdude: NOTE: &quot;flash&quot; memory has been specified, an erase cycle will be performed</span></span>\n<span class="line"><span>         To disable this feature, specify the -D option.</span></span>\n<span class="line"><span>avrdude: erasing chip</span></span>\n<span class="line"><span>avrdude: reading input file &quot;Caterina-Micro.hex&quot;</span></span>\n<span class="line"><span>avrdude: writing flash (32730 bytes):</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>Writing | ################################################## | 100% 11.58s</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>avrdude: 32730 bytes of flash written</span></span>\n<span class="line"><span>avrdude: verifying flash memory against Caterina-Micro.hex:</span></span>\n<span class="line"><span>avrdude: load data flash data from input file Caterina-Micro.hex:</span></span>\n<span class="line"><span>avrdude: input file Caterina-Micro.hex contains 32730 bytes</span></span>\n<span class="line"><span>avrdude: reading on-chip flash data:</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>Reading | ################################################## | 100% 10.33s</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>avrdude: verifying ...</span></span>\n<span class="line"><span>avrdude: 32730 bytes of flash verified</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>avrdude: safemode: Fuses OK (E:CB, H:D8, L:FF)</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>avrdude done.  Thank you.</span></span></code></pre></div><h3 id="setting-the-fuses" tabindex="-1">Setting the Fuses <a class="header-anchor" href="#setting-the-fuses" aria-label="Permalink to &quot;Setting the Fuses&quot;">​</a></h3><p>This is a slightly more advanced topic, but may be necessary if you are switching from one bootloader to another (for example, Caterina to Atmel/QMK DFU on a Pro Micro). Fuses control some of the low-level functionality of the AVR microcontroller, such as clock speed, whether JTAG is enabled, and the size of the section of flash memory reserved for the bootloader, among other things. You can find a fuse calculator for many AVR parts <a href="https://www.engbedded.com/conffuse/" target="_blank" rel="noreferrer">here</a>.</p><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>Setting incorrect fuse values, in particular the clock-related bits, may render the MCU practically unrecoverable without high voltage programming (not covered here)! Make sure to double check the commands you enter before you execute them.</p></div><p>To set the fuses, add the following to the <code>avrdude</code> command:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>-U lfuse:w:0xXX:m -U hfuse:w:0xXX:m -U efuse:w:0xXX:m</span></span></code></pre></div><p>where the <code>lfuse</code>, <code>hfuse</code> and <code>efuse</code> arguments represent the low, high and extended fuse bytes as listed in the <a href="#hardware">Hardware</a> section.</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>You may get a warning from <code>avrdude</code> that the extended fuse byte does not match what you provided when reading it back. If the second hex digit matches, this can usually be safely ignored, because the top four bits of this fuse do not actually exist on many AVR parts, and may read back as anything.</p></div><h2 id="creating-a-production-firmware" tabindex="-1">Creating a &quot;Production&quot; Firmware <a class="header-anchor" href="#creating-a-production-firmware" aria-label="Permalink to &quot;Creating a &quot;Production&quot; Firmware&quot;">​</a></h2><p>For mass production purposes, it is possible to join the bootloader and QMK firmware together into a single file, due to the way the <a href="https://en.wikipedia.org/wiki/Intel_HEX" target="_blank" rel="noreferrer">Intel Hex format</a> works:</p><ol><li>Open the QMK firmware and bootloader <code>.hex</code> files in a text editor.</li><li>Remove the last line of the QMK firmware (which should be <code>:00000001FF</code> - this is just an &quot;end of file&quot; marker).</li><li>Paste the contents of the bootloader <code>.hex</code> file onto a new line at the end of the QMK firmware file, with no empty lines between.</li><li>Save it as a new file, for example <code>&lt;keyboard&gt;_&lt;keymap&gt;_production.hex</code>.</li></ol><p>You can then ISP flash this combined firmware instead, which allows you to skip the extra step of flashing the QMK firmware over USB.</p><h2 id="flashing-stm32duino-bootloader" tabindex="-1">Flashing STM32Duino Bootloader <a class="header-anchor" href="#flashing-stm32duino-bootloader" aria-label="Permalink to &quot;Flashing STM32Duino Bootloader&quot;">​</a></h2><p>As mentioned above, <em>most</em> supported STM32 devices already possess a USB DFU bootloader which cannot be overwritten, however the ROM bootloader in the STM32F103 used on the Bluepill is not USB capable. In this case an ST-Link V2 dongle is required to upload the STM32Duino bootloader to the device. These can be readily purchased for relatively cheap on eBay and other places.</p><p>This bootloader is a descendant of the Maple bootloader by Leaflabs, and is compatible with dfu-util.</p><h3 id="software-1" tabindex="-1">Software <a class="header-anchor" href="#software-1" aria-label="Permalink to &quot;Software&quot;">​</a></h3><p>To communicate with the ST-Link, you must install the following packages:</p><ul><li><strong>macOS:</strong> <code>brew install stlink openocd</code></li><li><strong>Windows (MSYS2):</strong> <code>pacman -S mingw-w64-x86_64-stlink mingw-w64-x86_64-openocd</code></li><li><strong>Linux:</strong> will vary by distribution, but will likely be <code>stlink</code> and <code>openocd</code> through your particular package manager</li></ul><p>Additionally, you may need to update the ST-Link&#39;s firmware with the <a href="https://www.st.com/en/development-tools/stsw-link007.html" target="_blank" rel="noreferrer"><code>STSW-LINK007</code></a> application. Note you will be asked to provide your name and email address if you do not have an ST.com account (this does not create one).</p><p>Finally, the bootloader binary itself can be downloaded from <a href="https://github.com/rogerclarkmelbourne/STM32duino-bootloader/blob/master/bootloader_only_binaries/generic_boot20_pc13.bin" target="_blank" rel="noreferrer">here</a>.</p><h3 id="wiring-6" tabindex="-1">Wiring <a class="header-anchor" href="#wiring-6" aria-label="Permalink to &quot;Wiring&quot;">​</a></h3><p>Connect the four-pin header on the end of the Bluepill to the matching pins on the ST-Link (the pinout will usually be printed on the side):</p><table><thead><tr><th>ST-Link</th><th>Bluepill</th></tr></thead><tbody><tr><td><code>GND</code> (6)</td><td><code>GND</code></td></tr><tr><td><code>SWCLK</code> (2)</td><td><code>DCLK</code></td></tr><tr><td><code>SWDIO</code> (4)</td><td><code>DIO</code></td></tr><tr><td><code>3.3V</code> (8)</td><td><code>3.3</code></td></tr></tbody></table><h3 id="flashing" tabindex="-1">Flashing <a class="header-anchor" href="#flashing" aria-label="Permalink to &quot;Flashing&quot;">​</a></h3><p>Firstly, make sure both jumpers on the Bluepill are set to 0.</p><p>Check that the ST-Link can talk to the Bluepill by running <code>st-info --probe</code>:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>Found 1 stlink programmers</span></span>\n<span class="line"><span>  version:    V2J37S7</span></span>\n<span class="line"><span>  serial:     2C1219002B135937334D4E00</span></span>\n<span class="line"><span>  flash:      65536 (pagesize: 1024)</span></span>\n<span class="line"><span>  sram:       20480</span></span>\n<span class="line"><span>  chipid:     0x0410</span></span>\n<span class="line"><span>  descr:      F1xx Medium-density</span></span></code></pre></div><p>If the reported <code>chipid</code> is <code>0x0410</code>, everything is working. If it is <code>0x0000</code>, check your wiring, and try swapping the <code>SWDIO</code> and <code>SWCLK</code> pins, as some ST-Link dongles may have incorrect pinouts.</p><p>Next, run the following command:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>st-flash --reset --format binary write &lt;path-to-bootloader&gt; 0x08000000</span></span></code></pre></div><p>where <code>&lt;path-to-bootloader&gt;</code> is the path to the bootloader <code>.bin</code> file above. You can run this command from the directory you downloaded it to, so that you can simply pass in the filename.</p><p>If all goes well, you should get output similar to the following:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>st-flash 1.7.0</span></span>\n<span class="line"><span>2022-03-08T12:16:30 INFO common.c: F1xx Medium-density: 20 KiB SRAM, 64 KiB flash in at least 1 KiB pages.</span></span>\n<span class="line"><span>file generic_boot20_pc13.bin md5 checksum: 333c30605e739ce9bedee5999fdaf81b, stlink checksum: 0x0008e534</span></span>\n<span class="line"><span>2022-03-08T12:16:30 INFO common.c: Attempting to write 7172 (0x1c04) bytes to stm32 address: 134217728 (0x8000000)</span></span>\n<span class="line"><span>2022-03-08T12:16:30 INFO common.c: Flash page at addr: 0x08000000 erased</span></span>\n<span class="line"><span>2022-03-08T12:16:30 INFO common.c: Flash page at addr: 0x08000400 erased</span></span>\n<span class="line"><span>2022-03-08T12:16:31 INFO common.c: Flash page at addr: 0x08000800 erased</span></span>\n<span class="line"><span>2022-03-08T12:16:31 INFO common.c: Flash page at addr: 0x08000c00 erased</span></span>\n<span class="line"><span>2022-03-08T12:16:31 INFO common.c: Flash page at addr: 0x08001000 erased</span></span>\n<span class="line"><span>2022-03-08T12:16:31 INFO common.c: Flash page at addr: 0x08001400 erased</span></span>\n<span class="line"><span>2022-03-08T12:16:31 INFO common.c: Flash page at addr: 0x08001800 erased</span></span>\n<span class="line"><span>2022-03-08T12:16:31 INFO common.c: Flash page at addr: 0x08001c00 erased</span></span>\n<span class="line"><span>2022-03-08T12:16:31 INFO common.c: Finished erasing 8 pages of 1024 (0x400) bytes</span></span>\n<span class="line"><span>2022-03-08T12:16:31 INFO common.c: Starting Flash write for VL/F0/F3/F1_XL</span></span>\n<span class="line"><span>2022-03-08T12:16:31 INFO flash_loader.c: Successfully loaded flash loader in sram</span></span>\n<span class="line"><span>2022-03-08T12:16:31 INFO flash_loader.c: Clear DFSR</span></span>\n<span class="line"><span>  8/  8 pages written</span></span>\n<span class="line"><span>2022-03-08T12:16:31 INFO common.c: Starting verification of write complete</span></span>\n<span class="line"><span>2022-03-08T12:16:31 INFO common.c: Flash written and verified! jolly good!</span></span>\n<span class="line"><span>2022-03-08T12:16:31 WARN common.c: NRST is not connected</span></span></code></pre></div><p>Otherwise, if you receive an <code>Unknown memory region</code> error, run the following command to unlock the STM32F103:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>openocd -f interface/stlink.cfg -f target/stm32f1x.cfg -c &quot;init; reset halt; stm32f1x unlock 0; reset halt; exit&quot;</span></span></code></pre></div><p>Then re-plug the ST-Link and try again.</p><p>After all of this, unplug the Bluepill from the ST-Link and connect it to USB. It should now be ready to flash using dfu-util, the QMK CLI or Toolbox.</p>', 112);
const _hoisted_113 = [
  _hoisted_1
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, _hoisted_113);
}
const isp_flashing_guide = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export {
  __pageData,
  isp_flashing_guide as default
};

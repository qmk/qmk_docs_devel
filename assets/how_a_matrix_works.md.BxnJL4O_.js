import { _ as _export_sfc, c as createElementBlock, o as openBlock, a8 as createStaticVNode } from "./chunks/framework.Cauyuiy8.js";
const __pageData = JSON.parse('{"title":"How a Keyboard Matrix Works","description":"","frontmatter":{},"headers":[],"relativePath":"how_a_matrix_works.md","filePath":"how_a_matrix_works.md","lastUpdated":1751656200000}');
const _sfc_main = { name: "how_a_matrix_works.md" };
const _hoisted_1 = /* @__PURE__ */ createStaticVNode('<h1 id="how-a-keyboard-matrix-works" tabindex="-1">How a Keyboard Matrix Works <a class="header-anchor" href="#how-a-keyboard-matrix-works" aria-label="Permalink to &quot;How a Keyboard Matrix Works&quot;">​</a></h1><p>Keyboard switch matrices are arranged in rows and columns. Without a matrix circuit, each switch would require its own wire directly to the controller.</p><p>When the circuit is arranged in rows and columns, if a key is pressed, a column wire makes contact with a row wire and completes a circuit. The keyboard controller detects this closed circuit and registers it as a key press.</p><p>The microcontroller will be set up via the firmware to send a logical 1 to the columns, one at a time, and read from the rows, all at once - this process is called matrix scanning. The matrix is a bunch of open switches that, by default, don&#39;t allow any current to pass through - the firmware will read this as no keys being pressed. As soon as you press one key down, the logical 1 that was coming from the column the keyswitch is attached to gets passed through the switch and to the corresponding row - check out the following 2x2 example:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>        Column 0 being scanned     Column 1 being scanned</span></span>\n<span class="line"><span>                  x                                   x</span></span>\n<span class="line"><span>                 col0     col1              col0     col1</span></span>\n<span class="line"><span>                  |        |                 |        |</span></span>\n<span class="line"><span>        row0 ---(key0)---(key1)    row0 ---(key0)---(key1)</span></span>\n<span class="line"><span>                  |        |                 |        |</span></span>\n<span class="line"><span>        row1 ---(key2)---(key3)    row1 ---(key2)---(key3)</span></span></code></pre></div><p>The <code>x</code> represents that the column/row associated has a value of 1, or is HIGH. Here, we see that no keys are being pressed, so no rows get an <code>x</code>. For one keyswitch, keep in mind that one side of the contacts is connected to its row, and the other, its column.</p><p>When we press <code>key0</code>, <code>col0</code> gets connected to <code>row0</code>, so the values that the firmware receives for that row is <code>0b01</code> (the <code>0b</code> here means that this is a bit value, meaning all of the following digits are bits - 0 or 1 - and represent the keys in that column). We&#39;ll use this notation to show when a keyswitch has been pressed, to show that the column and row are being connected:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>        Column 0 being scanned     Column 1 being scanned</span></span>\n<span class="line"><span>                  x                                   x</span></span>\n<span class="line"><span>                 col0     col1              col0     col1</span></span>\n<span class="line"><span>                  |        |                 |        |</span></span>\n<span class="line"><span>      x row0 ---(-+-0)---(key1)    row0 ---(-+-0)---(key1)</span></span>\n<span class="line"><span>                  |        |                 |        |</span></span>\n<span class="line"><span>        row1 ---(key2)---(key3)    row1 ---(key2)---(key3)</span></span></code></pre></div><p>We can now see that <code>row0</code> has an <code>x</code>, so has the value of 1. As a whole, the data the firmware receives when <code>key0</code> is pressed is:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>col0: 0b01</span></span>\n<span class="line"><span>col1: 0b00</span></span>\n<span class="line"><span>        │└row0</span></span>\n<span class="line"><span>        └row1</span></span></code></pre></div><p>A problem arises when you start pressing more than one key at a time. Looking at our matrix again, it should become pretty obvious:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>        Column 0 being scanned     Column 1 being scanned</span></span>\n<span class="line"><span>                  x                                   x</span></span>\n<span class="line"><span>                 col0     col1              col0     col1</span></span>\n<span class="line"><span>                  |        |                 |        |</span></span>\n<span class="line"><span>      x row0 ---(-+-0)---(-+-1)  x row0 ---(-+-0)---(-+-1)</span></span>\n<span class="line"><span>                  |        |                 |        |</span></span>\n<span class="line"><span>      x row1 ---(key2)---(-+-3)  x row1 ---(key2)---(-+-3)</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>      Remember that this ^ is still connected to row1</span></span></code></pre></div><p>The data we get from that is:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>col0: 0b11</span></span>\n<span class="line"><span>col1: 0b11</span></span>\n<span class="line"><span>        │└row0</span></span>\n<span class="line"><span>        └row1</span></span></code></pre></div><p>Which isn&#39;t accurate, since we only have 3 keys pressed down, not all 4. This behavior is called ghosting, and only happens in odd scenarios like this, but can be much more common on a bigger keyboard. The way we can get around this is by placing a diode after the keyswitch, but before it connects to its row. A diode only allows current to pass through one way, which will protect our other columns/rows from being activated in the previous example. We&#39;ll represent a dioded matrix like this;</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>        Column 0 being scanned     Column 1 being scanned</span></span>\n<span class="line"><span>                    x                                   x</span></span>\n<span class="line"><span>                  col0      col1              col0     col1</span></span>\n<span class="line"><span>                    │        │                 |        │</span></span>\n<span class="line"><span>                 (key0)   (key1)            (key0)   (key1)</span></span>\n<span class="line"><span>                  ! │      ! │               ! |      ! │</span></span>\n<span class="line"><span>        row0 ─────┴────────┘ │     row0 ─────┴────────┘ │</span></span>\n<span class="line"><span>                    │        │                 |        │</span></span>\n<span class="line"><span>                 (key2)   (key3)            (key2)   (key3)</span></span>\n<span class="line"><span>                  !        !                 !        !</span></span>\n<span class="line"><span>        row1 ─────┴────────┘       row1 ─────┴────────┘</span></span></code></pre></div><p>In practical applications, the black line of the diode will be placed facing the row, and away from the keyswitch - the <code>!</code> in this case is the diode, where the gap represents the black line. A good way to remember this is to think of this symbol: <code>&gt;|</code></p><p>Now when we press the three keys, invoking what would be a ghosting scenario:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>        Column 0 being scanned     Column 1 being scanned</span></span>\n<span class="line"><span>                    x                                   x</span></span>\n<span class="line"><span>                  col0      col1              col0     col1</span></span>\n<span class="line"><span>                    │        │                 │        │</span></span>\n<span class="line"><span>                 (┌─┤0)   (┌─┤1)            (┌─┤0)   (┌─┤1)</span></span>\n<span class="line"><span>                  ! │      ! │               ! │      ! │</span></span>\n<span class="line"><span>      x row0 ─────┴────────┘ │   x row0 ─────┴────────┘ │</span></span>\n<span class="line"><span>                    │        │                 │        │</span></span>\n<span class="line"><span>                 (key2)   (┌─┘3)            (key2)   (┌─┘3)</span></span>\n<span class="line"><span>                  !        !                 !        !</span></span>\n<span class="line"><span>        row1 ─────┴────────┘     x row1 ─────┴────────┘</span></span></code></pre></div><p>Things act as they should! Which will get us the following data:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>col0: 0b01</span></span>\n<span class="line"><span>col1: 0b11</span></span>\n<span class="line"><span>        │└row0</span></span>\n<span class="line"><span>        └row1</span></span></code></pre></div><p>The firmware can then use this correct data to detect what it should do, and eventually, what signals it needs to send to the OS.</p><p>Further reading:</p><ul><li><a href="https://en.wikipedia.org/wiki/Keyboard_matrix_circuit" target="_blank" rel="noreferrer">Wikipedia article</a></li><li><a href="https://deskthority.net/wiki/Keyboard_matrix" target="_blank" rel="noreferrer">Deskthority article</a></li><li><a href="https://www.dribin.org/dave/keyboard/one_html/" target="_blank" rel="noreferrer">Keyboard Matrix Help by Dave Dribin (2000)</a></li><li><a href="https://pcbheaven.com/wikipages/How_Key_Matrices_Works/" target="_blank" rel="noreferrer">How Key Matrices Works by PCBheaven</a> (animated examples)</li><li><a href="./how_keyboards_work">How keyboards work - QMK documentation</a></li></ul>', 24);
const _hoisted_25 = [
  _hoisted_1
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, _hoisted_25);
}
const how_a_matrix_works = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export {
  __pageData,
  how_a_matrix_works as default
};

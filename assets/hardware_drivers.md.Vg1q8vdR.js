import { _ as _export_sfc, c as createElementBlock, o as openBlock, a8 as createStaticVNode } from "./chunks/framework.Cauyuiy8.js";
const __pageData = JSON.parse('{"title":"QMK Hardware Drivers","description":"","frontmatter":{},"headers":[],"relativePath":"hardware_drivers.md","filePath":"hardware_drivers.md","lastUpdated":1751656200000}');
const _sfc_main = { name: "hardware_drivers.md" };
const _hoisted_1 = /* @__PURE__ */ createStaticVNode('<h1 id="qmk-hardware-drivers" tabindex="-1">QMK Hardware Drivers <a class="header-anchor" href="#qmk-hardware-drivers" aria-label="Permalink to &quot;QMK Hardware Drivers&quot;">​</a></h1><p>QMK is used on a lot of different hardware. While support for the most common MCU&#39;s and matrix configurations is built-in there are a number of drivers that can be added to a keyboard to support additional hardware. Examples include mice and other pointing devices, i/o expanders for split keyboards, bluetooth modules, and LCD, OLED, and TFT screens.</p><h1 id="available-drivers" tabindex="-1">Available Drivers <a class="header-anchor" href="#available-drivers" aria-label="Permalink to &quot;Available Drivers&quot;">​</a></h1><h2 id="promicro-avr-only" tabindex="-1">ProMicro (AVR Only) <a class="header-anchor" href="#promicro-avr-only" aria-label="Permalink to &quot;ProMicro (AVR Only)&quot;">​</a></h2><p>Support for addressing pins on the ProMicro by their Arduino name rather than their AVR name. This needs to be better documented, if you are trying to do this and reading the code doesn&#39;t help please <a href="https://github.com/qmk/qmk_firmware/issues/new" target="_blank" rel="noreferrer">open an issue</a> and we can help you through the process.</p><h2 id="ssd1306-oled-driver" tabindex="-1">SSD1306 OLED Driver <a class="header-anchor" href="#ssd1306-oled-driver" aria-label="Permalink to &quot;SSD1306 OLED Driver&quot;">​</a></h2><p>Support for SSD1306 based OLED displays. For more information see the <a href="./features/oled_driver">OLED Driver Feature</a> page.</p><h2 id="ws2812" tabindex="-1">WS2812 <a class="header-anchor" href="#ws2812" aria-label="Permalink to &quot;WS2812&quot;">​</a></h2><p>Support for WS2811/WS2812{a,b,c} LED&#39;s. For more information see the <a href="./features/rgblight">RGB Light</a> page.</p><h2 id="is31fl3731" tabindex="-1">IS31FL3731 <a class="header-anchor" href="#is31fl3731" aria-label="Permalink to &quot;IS31FL3731&quot;">​</a></h2><p>Support for up to 2 drivers. Each driver impliments 2 charlieplex matrices to individually address LEDs using I2C. This allows up to 144 same color LEDs or 32 RGB LEDs. For more information on how to setup the driver see the <a href="./features/rgb_matrix">RGB Matrix</a> page.</p><h2 id="is31fl3733" tabindex="-1">IS31FL3733 <a class="header-anchor" href="#is31fl3733" aria-label="Permalink to &quot;IS31FL3733&quot;">​</a></h2><p>Support for up to a single driver with room for expansion. Each driver can control 192 individual LEDs or 64 RGB LEDs. For more information on how to setup the driver see the <a href="./features/rgb_matrix">RGB Matrix</a> page.</p><h2 id="_24xx-series-external-i2c-eeprom" tabindex="-1">24xx series external I2C EEPROM <a class="header-anchor" href="#_24xx-series-external-i2c-eeprom" aria-label="Permalink to &quot;24xx series external I2C EEPROM&quot;">​</a></h2><p>Support for an external I2C-based EEPROM instead of using the on-chip EEPROM. For more information on how to setup the driver see the <a href="./drivers/eeprom">EEPROM Driver</a> page.</p>', 15);
const _hoisted_16 = [
  _hoisted_1
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, _hoisted_16);
}
const hardware_drivers = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export {
  __pageData,
  hardware_drivers as default
};

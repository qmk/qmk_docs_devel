import { _ as _export_sfc, c as createElementBlock, o as openBlock, a8 as createStaticVNode } from "./chunks/framework.Cauyuiy8.js";
const __pageData = JSON.parse('{"title":"Dynamic Macros: Record and Replay Macros in Runtime","description":"","frontmatter":{},"headers":[],"relativePath":"features/dynamic_macros.md","filePath":"features/dynamic_macros.md","lastUpdated":1751656200000}');
const _sfc_main = { name: "features/dynamic_macros.md" };
const _hoisted_1 = /* @__PURE__ */ createStaticVNode('<h1 id="dynamic-macros-record-and-replay-macros-in-runtime" tabindex="-1">Dynamic Macros: Record and Replay Macros in Runtime <a class="header-anchor" href="#dynamic-macros-record-and-replay-macros-in-runtime" aria-label="Permalink to &quot;Dynamic Macros: Record and Replay Macros in Runtime&quot;">​</a></h1><p>QMK supports temporary macros created on the fly. We call these Dynamic Macros. They are defined by the user from the keyboard and are lost when the keyboard is unplugged or otherwise rebooted.</p><p>You can store one or two macros and they may have a combined total of 128 keypresses. You can increase this size at the cost of RAM.</p><p>To enable them, first include <code>DYNAMIC_MACRO_ENABLE = yes</code> in your <code>rules.mk</code>. Then, add the following keys to your keymap:</p><table><thead><tr><th>Key</th><th>Alias</th><th>Description</th></tr></thead><tbody><tr><td><code>QK_DYNAMIC_MACRO_RECORD_START_1</code></td><td><code>DM_REC1</code></td><td>Start recording Macro 1</td></tr><tr><td><code>QK_DYNAMIC_MACRO_RECORD_START_2</code></td><td><code>DM_REC2</code></td><td>Start recording Macro 2</td></tr><tr><td><code>QK_DYNAMIC_MACRO_PLAY_1</code></td><td><code>DM_PLY1</code></td><td>Replay Macro 1</td></tr><tr><td><code>QK_DYNAMIC_MACRO_PLAY_2</code></td><td><code>DM_PLY2</code></td><td>Replay Macro 2</td></tr><tr><td><code>QK_DYNAMIC_MACRO_RECORD_STOP</code></td><td><code>DM_RSTP</code></td><td>Finish the macro that is currently being recorded.</td></tr></tbody></table><p>That should be everything necessary.</p><p>To start recording the macro, press either <code>DM_REC1</code> or <code>DM_REC2</code>.</p><p>To finish the recording, press the <code>DM_RSTP</code> layer button. You can also press <code>DM_REC1</code> or <code>DM_REC2</code> again to stop the recording.</p><p>To replay the macro, press either <code>DM_PLY1</code> or <code>DM_PLY2</code>.</p><p>It is possible to replay a macro as part of a macro. It&#39;s ok to replay macro 2 while recording macro 1 and vice versa but never create recursive macros i.e. macro 1 that replays macro 1. If you do so and the keyboard will get unresponsive, unplug the keyboard and plug it again. You can disable this completely by defining <code>DYNAMIC_MACRO_NO_NESTING</code> in your <code>config.h</code> file.</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>For the details about the internals of the dynamic macros, please read the comments in the <code>process_dynamic_macro.h</code> and <code>process_dynamic_macro.c</code> files.</p></div><h2 id="customization" tabindex="-1">Customization <a class="header-anchor" href="#customization" aria-label="Permalink to &quot;Customization&quot;">​</a></h2><p>There are a number of options added that should allow some additional degree of customization</p><table><thead><tr><th>Define</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><code>DYNAMIC_MACRO_SIZE</code></td><td>128</td><td>Sets the amount of memory that Dynamic Macros can use. This is a limited resource, dependent on the controller.</td></tr><tr><td><code>DYNAMIC_MACRO_USER_CALL</code></td><td><em>Not defined</em></td><td>Defining this falls back to using the user <code>keymap.c</code> file to trigger the macro behavior.</td></tr><tr><td><code>DYNAMIC_MACRO_NO_NESTING</code></td><td><em>Not Defined</em></td><td>Defining this disables the ability to call a macro from another macro (nested macros).</td></tr><tr><td><code>DYNAMIC_MACRO_DELAY</code></td><td><em>Not Defined</em></td><td>Sets the waiting time (ms unit) when sending each key.</td></tr></tbody></table><p>If the LEDs start blinking during the recording with each keypress, it means there is no more space for the macro in the macro buffer. To fit the macro in, either make the other macro shorter (they share the same buffer) or increase the buffer size by adding the <code>DYNAMIC_MACRO_SIZE</code> define in your <code>config.h</code> (default value: 128; please read the comments for it in the header).</p><h3 id="dynamic-macro-user-call" tabindex="-1">DYNAMIC_MACRO_USER_CALL <a class="header-anchor" href="#dynamic-macro-user-call" aria-label="Permalink to &quot;DYNAMIC_MACRO_USER_CALL&quot;">​</a></h3><p>For users of the earlier versions of dynamic macros: It is still possible to finish the macro recording using just the layer modifier used to access the dynamic macro keys, without a dedicated <code>DM_RSTP</code> key. If you want this behavior back, add <code>#define DYNAMIC_MACRO_USER_CALL</code> to your <code>config.h</code> and insert the following snippet at the beginning of your <code>process_record_user()</code> function:</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	uint16_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> macro_kc </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (keycode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MO</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(_DYN) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> DM_RSTP </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> keycode);</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">process_record_dynamic_macro</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(macro_kc, record)) {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">		return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span></code></pre></div><h3 id="user-hooks" tabindex="-1">User Hooks <a class="header-anchor" href="#user-hooks" aria-label="Permalink to &quot;User Hooks&quot;">​</a></h3><p>There are a number of hooks that you can use to add custom functionality and feedback options to Dynamic Macro feature. This allows for some additional degree of customization.</p><p>Note, that direction indicates which macro it is, with <code>1</code> being Macro 1, <code>-1</code> being Macro 2, and 0 being no macro.</p><ul><li><code>dynamic_macro_record_start_user(int8_t direction)</code> - Triggered when you start recording a macro.</li><li><code>dynamic_macro_play_user(int8_t direction)</code> - Triggered when you play back a macro.</li><li><code>dynamic_macro_record_key_user(int8_t direction, keyrecord_t *record)</code> - Triggered on each keypress while recording a macro.</li><li><code>dynamic_macro_record_end_user(int8_t direction)</code> - Triggered when the macro recording is stopped.</li></ul><p>Additionally, you can call <code>dynamic_macro_led_blink()</code> to flash the backlights if that feature is enabled.</p>', 23);
const _hoisted_24 = [
  _hoisted_1
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, _hoisted_24);
}
const dynamic_macros = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export {
  __pageData,
  dynamic_macros as default
};

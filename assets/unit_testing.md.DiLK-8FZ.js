import { _ as _export_sfc, c as createElementBlock, o as openBlock, a8 as createStaticVNode } from "./chunks/framework.Cauyuiy8.js";
const __pageData = JSON.parse('{"title":"Unit Testing","description":"","frontmatter":{},"headers":[],"relativePath":"unit_testing.md","filePath":"unit_testing.md","lastUpdated":1751656200000}');
const _sfc_main = { name: "unit_testing.md" };
const _hoisted_1 = /* @__PURE__ */ createStaticVNode('<h1 id="unit-testing" tabindex="-1">Unit Testing <a class="header-anchor" href="#unit-testing" aria-label="Permalink to &quot;Unit Testing&quot;">​</a></h1><p>If you are new to unit testing, then you can find many good resources on internet. However most of it is scattered around in small pieces here and there, and there&#39;s also many different opinions, so I won&#39;t give any recommendations.</p><p>Instead I recommend these two books, explaining two different styles of Unit Testing in detail.</p><ul><li>&quot;Test Driven Development: By Example: Kent Beck&quot;</li><li>&quot;Growing Object-Oriented Software, Guided By Tests: Steve Freeman, Nat Pryce&quot;</li></ul><p>If you prefer videos there are Uncle Bob&#39;s <a href="https://cleancoders.com/" target="_blank" rel="noreferrer">Clean Coders Videos</a>, which unfortunately cost quite a bit, especially if you want to watch many of them. But James Shore has a free <a href="https://www.jamesshore.com/Blog/Lets-Play" target="_blank" rel="noreferrer">Let&#39;s Play</a> video series.</p><h2 id="google-test-and-google-mock" tabindex="-1">Google Test and Google Mock <a class="header-anchor" href="#google-test-and-google-mock" aria-label="Permalink to &quot;Google Test and Google Mock&quot;">​</a></h2><p>It&#39;s possible to Unit Test your code using <a href="https://github.com/google/googletest" target="_blank" rel="noreferrer">Google Test</a>. The Google Test framework also includes another component for writing testing mocks and stubs, called &quot;Google Mock&quot;. For information how to write the actual tests, please refer to the documentation on that site.</p><h2 id="use-of-c" tabindex="-1">Use of C++ <a class="header-anchor" href="#use-of-c" aria-label="Permalink to &quot;Use of C++&quot;">​</a></h2><p>Note that Google Test and therefore any test has to be written in C++, even if the rest of the QMK codebases is written in C. This should hopefully not be a problem even if you don&#39;t know any C++, since there&#39;s quite clear documentation and examples of the required C++ features, and you can write the rest of the test code almost as you would write normal C. Note that some compiler errors which you might get can look quite scary, but just read carefully what it says, and you should be ok.</p><p>One thing to remember, is that you have to append <code>extern &quot;C&quot;</code> around all of your C file includes.</p><h2 id="adding-tests-for-new-or-existing-features" tabindex="-1">Adding Tests for New or Existing Features <a class="header-anchor" href="#adding-tests-for-new-or-existing-features" aria-label="Permalink to &quot;Adding Tests for New or Existing Features&quot;">​</a></h2><p>If you want to unit test a feature, take a look at some of the existing tests, for example those in the <code>quantum/sequencer/tests</code> folder. Then follow the steps below to create a similar structure.</p><ol><li>If it doesn&#39;t already exist, add a test subfolder to the folder containing the feature.</li><li>Create a <code>testlist.mk</code> and a <code>rules.mk</code> file in that folder.</li><li>Include those files from the root folder <code>testlist.mk</code>and <code>build_test.mk</code> respectively.</li><li>Add a new name for your testgroup to the <code>testlist.mk</code> file. Each group defined there will be a separate executable. And that&#39;s how you can support mocking out different parts. Note that it&#39;s worth adding some common prefix, just like it&#39;s done for the existing tests. The reason for that is that the make command allows substring filtering, so this way you can easily run a subset of the tests.</li><li>Define the source files and required options in the <code>rules.mk</code> file. <ul><li><code>_SRC</code> for source files</li><li><code>_DEFS</code> for additional defines</li><li><code>_INC</code> for additional include folders</li></ul></li><li>Write the tests in a new cpp file inside the test folder you created. That file has to be one of the files included from the <code>rules.mk</code> file.</li></ol><p>Note how there&#39;s several different tests, each mocking out a separate part. Also note that each of them only compiles the very minimum that&#39;s needed for the tests. It&#39;s recommend that you try to do the same. For a relevant video check out <a href="https://www.youtube.com/watch?v=Wmy6g-aVgZI" target="_blank" rel="noreferrer">Matt Hargett &quot;Advanced Unit Testing in C &amp; C++</a></p><h2 id="running-the-tests" tabindex="-1">Running the Tests <a class="header-anchor" href="#running-the-tests" aria-label="Permalink to &quot;Running the Tests&quot;">​</a></h2><p>To run all the tests in the codebase, type <code>make test:all</code>. You can also run test matching a substring by typing <code>make test:matchingsubstring</code>. <code>matchingsubstring</code> can contain colons to be more specific; <code>make test:tap_hold_configurations</code> will run the <code>tap_hold_configurations</code> tests for all features while <code>make test:retro_shift:tap_hold_configurations</code> will run the <code>tap_hold_configurations</code> tests for only the Retro Shift feature.</p><p>Note that the tests are always compiled with the native compiler of your platform, so they are also run like any other program on your computer.</p><h2 id="debugging-the-tests" tabindex="-1">Debugging the Tests <a class="header-anchor" href="#debugging-the-tests" aria-label="Permalink to &quot;Debugging the Tests&quot;">​</a></h2><p>If there are problems with the tests, you can find the executable in the <code>./build/test</code> folder. You should be able to run those with GDB or a similar debugger.</p><p>To forward any <a href="./unit_testing#debug-api">debug messages</a> to <code>stderr</code>, the tests can run with <code>DEBUG=1</code>. For example</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>make test:all DEBUG=1</span></span></code></pre></div><p>Alternatively, add <code>CONSOLE_ENABLE=yes</code> to the tests <code>rules.mk</code>.</p><h2 id="full-integration-tests" tabindex="-1">Full Integration Tests <a class="header-anchor" href="#full-integration-tests" aria-label="Permalink to &quot;Full Integration Tests&quot;">​</a></h2><p>It&#39;s not yet possible to do a full integration test, where you would compile the whole firmware and define a keymap that you are going to test. However there are plans for doing that, because writing tests that way would probably be easier, at least for people that are not used to unit testing.</p><p>In that model you would emulate the input, and expect a certain output from the emulated keyboard.</p><h1 id="keycode-string" tabindex="-1">Keycode String <a class="header-anchor" href="#keycode-string" aria-label="Permalink to &quot;Keycode String {#keycode-string}&quot;">​</a></h1><p>It&#39;s much nicer to read keycodes as names like &quot;<code>LT(2,KC_D)</code>&quot; than numerical codes like &quot;<code>0x4207</code>.&quot; To convert keycodes to human-readable strings, add <code>KEYCODE_STRING_ENABLE = yes</code> to the <code>rules.mk</code> file, then use the <code>get_keycode_string(kc)</code> function to convert a given 16-bit keycode to a string.</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> char</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">key_name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> get_keycode_string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(keycode);</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">dprintf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;kc: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">%s\\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, key_name);</span></span></code></pre></div><p>The stringified keycode may then be logged to console output with <code>dprintf()</code> or elsewhere.</p><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>Use the result of <code>get_keycode_string()</code> immediately. Subsequent invocations reuse the same static buffer and overwrite the previous contents.</p></div><p>Many common QMK keycodes are recognized by <code>get_keycode_string()</code>, but not all. These include some common basic keycodes, layer switch keycodes, mod-taps, one-shot keycodes, tap dance keycodes, and Unicode keycodes. As a fallback, an unrecognized keycode is written as a hex number.</p><p>Optionally, <code>KEYCODE_STRING_NAMES_USER</code> may be defined to add names for additional keycodes. For example, supposing keymap.c defines <code>MYMACRO1</code> and <code>MYMACRO2</code> as custom keycodes, the following adds their names:</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">KEYCODE_STRING_NAMES_USER</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    KEYCODE_STRING_NAME</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(MYMACRO1),</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    KEYCODE_STRING_NAME</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(MYMACRO2),</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>Similarly, <code>KEYCODE_STRING_NAMES_KB</code> may be defined to add names at the keyboard level.</p><h1 id="tracing-variables" tabindex="-1">Tracing Variables <a class="header-anchor" href="#tracing-variables" aria-label="Permalink to &quot;Tracing Variables {#tracing-variables}&quot;">​</a></h1><p>Sometimes you might wonder why a variable gets changed and where, and this can be quite tricky to track down without having a debugger. It&#39;s of course possible to manually add print statements to track it, but you can also enable the variable trace feature. This works for both variables that are changed by the code, and when the variable is changed by some memory corruption.</p><p>To take the feature into use add <code>VARIABLE_TRACE=x</code> to the end of you make command. <code>x</code> represents the number of variables you want to trace, which is usually 1.</p><p>Then at a suitable place in the code, call <code>ADD_TRACED_VARIABLE</code>, to begin the tracing. For example to trace all the layer changes, you can do this</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> matrix_init_user</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  ADD_TRACED_VARIABLE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;layer&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">layer_state, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">sizeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(layer_state));</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>This will add a traced variable named &quot;layer&quot; (the name is just for your information), which tracks the memory location of <code>layer_state</code>. It tracks 4 bytes (the size of <code>layer_state</code>), so any modification to the variable will be reported. By default you can not specify a size bigger than 4, but you can change it by adding <code>MAX_VARIABLE_TRACE_SIZE=x</code> to the end of the make command line.</p><p>In order to actually detect changes to the variables you should call <code>VERIFY_TRACED_VARIABLES</code> around the code that you think that modifies the variable. If a variable is modified it will tell you between which two <code>VERIFY_TRACED_VARIABLES</code> calls the modification happened. You can then add more calls to track it down further. I don&#39;t recommend spamming the codebase with calls. It&#39;s better to start with a few, and then keep adding them in a binary search fashion. You can also delete the ones you don&#39;t need, as each call need to store the file name and line number in the ROM, so you can run out of memory if you add too many calls.</p><p>Also remember to delete all the tracing code once you have found the bug, as you wouldn&#39;t want to create a pull request with tracing code.</p>', 42);
const _hoisted_43 = [
  _hoisted_1
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, _hoisted_43);
}
const unit_testing = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export {
  __pageData,
  unit_testing as default
};
